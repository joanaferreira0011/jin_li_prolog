# Jin Lin 3 

**Game**: Jin Lin - [rules](https://nestorgames.com/rulebooks/JINLI_EN.pdf)

Group Members:

* Joana Ferreira - up201705722
* JosÃ© Silva - up201705591

## Installation and Running

Copy the `*.pl` files to a directory and start your prefered Prolog interpreter(must be compatible with SICStus).

To run: `consult('play.pl').`, this implies you're in the same directory as the file. In case of doubt use the full path.

## Game Description

Jin Li is a turn-based game played on a 7x7 board and the pieces are red/yellow koi(fish) and stones.

The game starts with each player putting 2 Koi on the corners  of their side of the board. Each turn the player can perform one of the two actions:

* Move one of its Koi to an adjancent empty square (ortogonal or diagonal) and place a **stone** in any empty square. If the player runs out of stones then he just moves the Koi without placing stones.

* Jump a Koi over a stone (ortogonal or diagonal), it must land on an empty square adjancent to the stone. 

### Scoring

At the end of each turn the player gets 1 point for each Koi adjacent to the new square of the Koi the player just moved.
First player to reach 10 points wins the game.


## Internal representation of the game

The board is represented as a list of lists (row-wise). The internal values are the following:

* 0 - empty square
* 1 - Red Koi
* 2 - Yellow Koi
* 3 - Stone

The render function then calls the `code/2` predicate to translate them to a human-friendly format:

* 0 -> 
* 1 -> R
* 2 -> Y
* 3 -> *


### Start of the game

Start of the game:
```
[
	[1, 0, 0, 0, 0, 0, 1],
	[0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0],
	[2, 0, 0, 0, 0, 0, 2]
] /* Generated by create_board/2 */

----------------------------
| R |   |   |   |   |   | R | 
----------------------------
|   |   |   |   |   |   |   | 
----------------------------
|   |   |   |   |   |   |   | 
----------------------------
|   |   |   |   |   |   |   | 
----------------------------
|   |   |   |   |   |   |   | 
----------------------------
|   |   |   |   |   |   |   | 
----------------------------
| Y |   |   |   |   |   | Y | 
----------------------------


Yellow's score: 0
Red's score: 0
```


Middle of the game:
```
middle_board([
	[3, 0, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 0],
	[0, 0, 3, 0, 0, 0, 3],
	[0, 0, 0, 2, 1, 0, 0],
	[0, 0, 0, 3, 0, 2, 0],
	[0, 1, 0, 0, 0, 0, 0],
	[0, 0, 0, 0, 0, 0, 3]
]).
		
----------------------------
| * |   |   |   |   |   |   | 
----------------------------
|   |   |   |   |   |   |   | 
----------------------------
|   |   | * |   |   |   | * | 
----------------------------
|   |   |   | Y | R |   |   | 
----------------------------
|   |   |   | * |   | Y |   | 
----------------------------
|   | R |   |   |   |   |   | 
----------------------------
|   |   |   |   |   |   | * | 
----------------------------

Yellow's score: 3
Red's score: 4
```

End of the game:

```
end_board([
	[3, 0, 0, 3, 0, 0, 0],
	[0, 0, 0, 0, 0, 3, 0],
	[0, 3, 3, 0, 0, 0, 3],
	[3, 1, 3, 0, 3, 0, 0],
	[0, 0, 0, 3, 3, 0, 0],
	[0, 0, 0, 1, 2, 0, 3],
	[3, 0, 0, 2, 3, 0, 3]
]).

----------------------------
| * |   |   | * |   |   |   | 
----------------------------
|   |   |   |   |   | * |   | 
----------------------------
|   | * | * |   |   |   | * | 
----------------------------
| * | R | * |   | * |   |   | 
----------------------------
|   |   |   | * | * |   |   | 
----------------------------
|   |   |   | R | Y |   | * | 
----------------------------
| * |   |   | Y | * |   | * | 
----------------------------


Yellow's score: 10
Red's score: 8

```
		

### Rendering the game

The predicate `print_board/1` takes the board (list of lists) as the an argument. It prints each line recursively and before calling the `print_line/1` predicate it prints the `|` character serving as the leftmost limit of the board.

`print_line/1` calls `print_cell/1` for each cell.

`print_cell/1` uses the predicate `code/2` to convert the internal representation of the game to a more human-readable format. After printing the translated character it appends `|` that serves as cell boundary and the rightmost board limit.





### Start Menu

Running `play/0`, will prompt the user to insert the length of the side of board - which must be bigger than 7.

After that the user chooses the players - Human(s) or Bot(s) - and who goes first.

*Example Interaction*
```

| ?- play.
How big do you want the board?(must be at least 7x7)
|: 10
Who should start?
0 - Human
1 - Bot
|: 0
Who should go second?
0 - Human
1 - Bot
|: 1
How smart you want the AI ? (max 4)
|: 2

```


Any type of match can be played: 
* Human VS Human
* Human VS Bot
* Bot VS Human
* Bot VS Bot

Different bot's difficulties can challenge each other!

## Game Logic


### Introduction

The entrypoint of the project is `play/0` which after setting up game's characteristics - board and players - goes into the `play_loop`. The `play_loop` is an agnostic game logic loop where the turns are represented in a list of length 2.

Each turn the head is popped and using the `univ` operator is turnt into the turn call that returns a `Move`. The `play_loop` will then try to apply the move itself, if it succeeds then it switches both list elements - representing turn switching - and goes into the nex turn.
If it fails then it implies the code for that specific turn is faulty and has some major issues.

### move

For simplicity reasons the `move/3` predicate was turnt into `move/2` since the player is always associated with the game state.
It was developed to take variables and non-variables as an argument thus not only it's able to play but to suggest moves!


Internal workings:
1. Move Koi - `move_koi/3`
2. Change the turn - using the turn table - `next_turn/2`
3. Place a rock if possible - `place_rock/4`
4. Update scores - `update_scores/4`


By performing early unifications this function was used to define all the others.


### valid_moves

Simple `findall` on `move/2` with an `unique/2` to filter repeated results.

```
valid_moves(GameState, ListOfMoves) :-
	findall(FromX-FromY-ToX-ToY-RockX-RockY, move(GameState, FromX-FromY-ToX-ToY-RockX-RockY, _), _ListOfMoves),
	unique(_ListOfMoves, ListOfMoves).
    
```


### game_over

Verifies whether the score of one of the players is 10 or above.

```
game_over(_-YellowScore,  2):-
	YellowScore >= 10.

% Red is the winner.
game_over(RedScore-_, 1):-
	RedScore >= 10.
```


### choose_move

If the Level is set to 0 then it will return a random `Move`.
Else it will perform the minimax algorithm with pruning until the `Level` depth.

```
choose_move(0, GameState, Move):-
	valid_moves(GameState, ListOfMoves),
	
	length(ListOfMoves, LengthList),
	
	random(0, LengthList, Rand),
	nth0(Rand, ListOfMoves, Move),
	
	move(GameState, 
	Move,
	_).
	
	
choose_move(Level, GameState, Move) :-
	Level > 0,
	minimax(Level, GameState, Move).
```


### value

Defining a value function for Jin Li was quite difficult due to the depth of each move.
After some playtesting it was concluded that aggressivelly joining the same player Kois was the best strategy.

In math terms this was developed into the difference of the Score and the area both Kois make. Thus the bigger the area the worse the play is!

```
% Heuristic subtracts the koi total area to promote them coming together
value(GameState, Value) :-
	Board-CurrentPlayer-_-_-RedScore-YellowScore = GameState,
	
	findall(X-Y, element_at_pos(Board, X-Y, CurrentPlayer), Kois),
	[Fx-Fy, Sx-Sy] = Kois,
	DeltaX is Fx-Sx,
	DeltaY is Fy-Sy,
	STotal is DeltaX*DeltaY,
	absolute(STotal, _Total),
	max_member(Total, [_Total, 1]),
	
	value(RedScore-YellowScore, CurrentPlayer, V),
	Value is V-Total.
	
	
value(RedScore-YellowScore, 2, Value):-
	MaxScore is max(YellowScore, RedScore),
	Value is (YellowScore-RedScore) * MaxScore.

value(RedScore-YellowScore, 1, Value):-
	MaxScore is max(YellowScore, RedScore),
	Value is (RedScore-YellowScore) * MaxScore.
```

## Conclusion

The code was developed with extensability in mind. This was definitely a task for us due to the inexperience with Prolog.
Designing and making `move` be the foundation to all other move related functions really helped debugging and improving readibility.
Any problem would surface quite easily and if any users of the `move` were correct then it must mean it's also correct!

Surprisingly the `univ` operator turned out to be quite useful too. First of all, for the `play_loop`, where it agnostically switches between turns of the players, not caring whether is a bot or a human.
Similarly for minimax, having the power to bind arguments to functions helped simplify a lot of the repeated code!


### Known Issues

Due to the exponentiallity of this game the `minimax` algorithm takes quite a while, even performing some naive pruning taking it to the 5th level and beyong is just not playable.

**Naive pruning** leads to the smarter bot to act dumber. Since we take a random permutation of all of the possible actions - to improve performance - and it's not based on any metric it sometimes ends up hurting the quality of the plays.

## Bibliography

[SWI Documentation](https://www.swi-prolog.org/pldoc/doc/_CWD_/index.html) - Easiest to find and most of the time compatible with SICStus

[SICStus Documentation](https://sicstus.sics.se/sicstus/docs/4.3.0/html/sicstus/lib_002dlists.html) - specifically the list operations page which differs from SWI

[Minimax](https://en.wikipedia.org/wiki/Minimax) - Get the pseudocode from
